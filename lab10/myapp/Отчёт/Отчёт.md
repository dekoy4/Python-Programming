```markdown
#Лабораторная работа 10: Методы оптимизации вычисления кода

**Численное интегрирование методом прямоугольников: Python → Потоки → Процессы → Cython**

## Цель работы
Исследовать методы оптимизации CPU-bound задачи:
1. Чистый Python (baseline)
2. Потоки (`ThreadPoolExecutor`) 
3. Процессы (`ProcessPoolExecutor`)
4. Cython (Итерация 4-5)

## Результаты бенчмарка

| n_iter    | Python   | Потоки  | Процессы | Вывод |
|-----------|----------|---------|----------|-------|
| **100k**  | **10.7мс** | 12.2мс | 165.6мс | **GIL + overhead** |
| **500k**  | **52.7мс** | -      | 185.9мс | Процессы **0.3x** |
| **1M**    | **107.8мс**| -     |**198.0мс**| Процессы **0.5x** |

**КЛЮЧЕВОЙ ВЫВОД:** Потоки медленнее Python из-за GIL. Процессы ещё медленнее,
потому что Windows multiprocessing имеет высокий overhead (Linux дал бы 3-4x)
Cython решил бы задачу лучше, но у меня никак не получилось скомпилировать его модули :(
```
## Структура проекта
```
lab10/myapp/
├── src/                    \# Python реализации (Итерации 1-3)
│   ├── integrate.py        \# Базовая функция + docstring + типы
│   ├── integrate_async.py  \# Потоки + процессы
│   └── __init__.py         \# Публичный API
├── tests/                  \# 8 юнит-тестов ✓
│   └── test_integrate.py
├── benchmarks/             \# Замеры timeit
│   ├── benchmark.py
│   ├── full_benchmark.py
│   └── process_test.py
├── cython/                 \# Итерации 4-5 (Не получилось)
│   ├── integrate_cython.pyx
│   └── __init__.py  
├── Отчёт/
│   ├── Отчёт.md            \# Этот файл
│   └── результаты.png      \# Скриншот
├── .gitignore
├── requirements.txt
└── run_cython.py

```
